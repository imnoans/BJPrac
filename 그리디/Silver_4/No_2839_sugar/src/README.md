
# 문제

---

상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.

상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.

상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.

# 입력

---

첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)

# 출력

---

상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.

# 풀이

----

배달해야 하는 중량 n, 5킬로그램 봉지의 수 five, 3킬로그램 봉지의 수 three, 남은 설탕의 중량 remain을 정의한다

    int n;
    int five, three, remain;

남는 것 없이 배달할 수 있는지의 여부 pos를 정의한다

    boolean pos = false;

n을 입력받는다

    n = Integer.parseInt(br.readLine());

five를 우선 n을 5로 나눈 몫으로 초기화한다

    five = n / 5;

three는 0으로 초기화한다.

    three = 0;

remain은 n을 5로 나눈 나머지 값을 저장한다
    
    remain = n % 5;

five가 0이하가 되면 해당 중량은 3, 5킬로그램으로 나누어 담을 수 없으므로 반복문을 종료한다

    while(five >= 0)
    
만약 remian을 3으로 나눈 나머지가 0이라면 모든 설탕을 담은 것이므로 
three에는 남은 설탕을 3킬로그램 봉지에 나누어 담은 개수를 저장하고 pos를 true로 변경한 뒤
while 문을 빠져나간다

    if(remain % 3 == 0)
    {
        three = remain / 3;
        pos = true;
        break;
    }

만약 remian을 3으로 나눈 나머지가 0이 아니라면 5킬로그램 봉지 수를 하나 줄이고
ramain을 5증가시킨 뒤 다시 3으로 나누어 떨어지는지 검사한다

    five--;
    remain += 5;

while 문이 종료된 후 pos가 true라면 five와 three를 더한 값을 출력한다.

    if(pos)
    {
        bw.write("" + (five + three));
    }

pos가 false라면 배달할 수 없으므로 -1을 출력한다

    else
    {
        bw.write("-1");
    }
    bw.close();
